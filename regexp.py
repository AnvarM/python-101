pattern = r"a[abc]c"
string = "acc"
r"string\n\t\t\t\t" # выведет строку как есть и не будет обрабатывать спецсимволы
re.match(pattern, string) # берет шаблон и заданную строку и провер€ет подходит ли данна€ строка под шаблон
re.search(pattern, string) # берет строку и находит первую подстроку котора€ соответствует шаблону
re.findall(pattern, string) # найдет все строки подход€щие под шаблон
re.sub(pattern, "some_string", string) # заменит строки подход€щие под шаблон строкой some_string

[abc] # любой из символов из последовательности    
# метасимволы вида ?, $, \ ... при создании шаблона должны экранироватьс€ символом "\" если на нужны эти символы именно как часть строки в шаблоне
# метасимволы:
    # [a-d] = [abcd]
    # [a-cA-c] = [abcABC]
    # [^abc] - означает что эти символы не подход€т
    # \d = [0-9]
    # \D = [^0-9]
    # \s = [ \t\n\r\f\v] - все пробельные символы
    # \S = [^ \t\n\r\f\v]
    # \w = [a-zA-Z0-9_] - буквы + цифры + _
    # \W = [^a-zA-z0-9_]
    # . - любой символ кроме переноса строки
    # b* - любое количество символов b, даже 0
    # b+ - любое количество символов b > 0
    # b? - 0 или 1 вхождение b
    # b{3} - конкретное число вхождений
    # b{2,4} - диапазон количества вхождений
    # + - жадный метасимвол, например:
        # patternt = r"a[ab]+a"
        # string = abaaba
        # re.match(pattern,string) - вернет всю строку, а не подстроку aba, котора€ тоже подходит под шаблон
    # +? - отбивает жадность), будет пытатьс€ найти подстроку наименьшей длинны удовлетвор€ющей шаблону   
    # (abcd) - будет искать abcd а не символы по отдельности
    # (abcd|abda) - будет искать abcd или abda "|" обладает наименьшим приоритетом
    # если указано несколько групп и подгрупп символов, в объекте match они все будут перечислены в кортеже
    
pattern = r"(\w+)- \1" # \1 здесь означает использовать группу символов (\w+), т.к. ее номер в списке групп будет 1, так можно обращатьс€ к разным группам, если их несколько        
re.sub(pattern, r"\1", string) # номера групп можно использовать при замене
re.match(pattern, string, flags = re.IGNORECASE) # будет игнорировать регистр букв при поиске совпадений